<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Software Painter</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: monospace; }
        canvas { display: block; cursor: crosshair; }
        #ui { position: absolute; top: 10px; left: 10px; background: #222; padding: 10px; display: flex; flex-direction: column; gap: 10px; border: 1px solid #444; }
        .row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
        select, button { background: #333; color: #fff; border: 1px solid #555; padding: 5px; }
    </style>
</head>
<body>

<div id="ui">
    <div class="row">üé® <input type="color" id="color" value="#00ffcc"></div>
    <div class="row">üì¶ 
        <select id="shape">
            <option value="cube">Cube</option>
            <option value="pyramid">Pyramid</option>
            <option value="knot">Torus Knot</option>
        </select>
    </div>
    <div class="row">üï∏Ô∏è <input type="checkbox" id="wireframe"> Wireframe</div>
    <button id="reset">üóëÔ∏è Reset</button>
</div>

<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const uiColor = document.getElementById('color');
    const uiShape = document.getElementById('shape');
    const uiWire = document.getElementById('wireframe');

    let width, height;
    let rotation = { x: 0.5, y: 0.5 };
    let faces = [];
    let isDragging = false;
    let lastMouse = { x: 0, y: 0 };

    const shapes = {
        cube: () => {
            const v = [
                [-1,-1,-1], [1,-1,-1], [1,1,-1], [-1,1,-1],
                [-1,-1,1], [1,-1,1], [1,1,1], [-1,1,1]
            ];
            return [
                { v: [0,1,2,3], c: '#444' }, { v: [4,5,6,7], c: '#444' },
                { v: [0,4,7,3], c: '#444' }, { v: [1,5,6,2], c: '#444' },
                { v: [0,1,5,4], c: '#444' }, { v: [3,2,6,7], c: '#444' }
            ].map(f => ({ ...f, pts: f.v.map(i => v[i]) }));
        },
        pyramid: () => {
            const v = [[0,1,0], [-1,-1,1], [1,-1,1], [1,-1,-1], [-1,-1,-1]];
            return [
                { v: [0,1,2], c: '#444' }, { v: [0,2,3], c: '#444' },
                { v: [0,3,4], c: '#444' }, { v: [0,4,1], c: '#444' },
                { v: [1,2,3,4], c: '#444' }
            ].map(f => ({ ...f, pts: f.v.map(i => v[i]) }));
        },
        knot: () => {
            const fcs = [];
            const steps = 20;
            const tubeSteps = 12;
            const getPos = (u, v) => {
                u *= Math.PI * 2;
                v *= Math.PI * 2;
                const p = 2, q = 3;
                const r = 0.5 * (2 + Math.sin(q * u));
                const x = r * Math.cos(p * u);
                const y = r * Math.sin(p * u);
                const z = r * Math.cos(q * u);
                // Simple tube approximation
                return [x + Math.cos(v) * 0.2, y + Math.sin(v) * 0.2, z];
            };
            for (let i = 0; i < steps; i++) {
                for (let j = 0; j < tubeSteps; j++) {
                    fcs.push({
                        pts: [
                            getPos(i/steps, j/tubeSteps),
                            getPos((i+1)/steps, j/tubeSteps),
                            getPos((i+1)/steps, (j+1)/tubeSteps),
                            getPos(i/steps, (j+1)/tubeSteps)
                        ],
                        c: '#444'
                    });
                }
            }
            return fcs;
        }
    };

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }

    function project(p) {
        const x = p[0] * Math.cos(rotation.y) - p[2] * Math.sin(rotation.y);
        const z1 = p[0] * Math.sin(rotation.y) + p[2] * Math.cos(rotation.y);
        const y = p[1] * Math.cos(rotation.x) - z1 * Math.sin(rotation.x);
        const z = p[1] * Math.sin(rotation.x) + z1 * Math.cos(rotation.x);
        const scale = 400 / (z + 5);
        return {
            x: x * scale + width / 2,
            y: y * scale + height / 2,
            z: z
        };
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);
        
        const rendered = faces.map(f => {
            const projected = f.pts.map(project);
            const avgZ = projected.reduce((sum, p) => sum + p.z, 0) / projected.length;
            return { f, projected, avgZ };
        }).sort((a, b) => b.avgZ - a.avgZ);

        rendered.forEach(r => {
            ctx.beginPath();
            ctx.moveTo(r.projected[0].x, r.projected[0].y);
            r.projected.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            
            ctx.fillStyle = r.f.c;
            ctx.fill();
            if (uiWire.checked) {
                ctx.strokeStyle = '#fff';
                ctx.stroke();
            }
        });
        requestAnimationFrame(draw);
    }

    function pointInPoly(x, y, poly) {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            if (((poly[i].y > y) !== (poly[j].y > y)) &&
                (x < (poly[j].x - poly[i].x) * (y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) {
                inside = !inside;
            }
        }
        return inside;
    }

    canvas.onmousedown = (e) => {
        isDragging = true;
        lastMouse = { x: e.clientX, y: e.clientY };
        
        const rendered = faces.map(f => ({ f, proj: f.pts.map(project) }))
            .map(r => ({ ...r, z: r.proj.reduce((s, p) => s + p.z, 0) / r.proj.length }))
            .sort((a, b) => a.z - b.z);

        for (let r of rendered) {
            if (pointInPoly(e.clientX, e.clientY, r.proj)) {
                r.f.c = uiColor.value;
                isDragging = false; // Prevent rotation on single paint click
                break;
            }
        }
    };

    window.onmousemove = (e) => {
        if (isDragging) {
            rotation.y += (e.clientX - lastMouse.x) * 0.01;
            rotation.x += (e.clientY - lastMouse.y) * 0.01;
            lastMouse = { x: e.clientX, y: e.clientY };
        }
    };

    window.onmouseup = () => isDragging = false;
    uiShape.onchange = () => faces = shapes[uiShape.value]();
    document.getElementById('reset').onclick = () => faces = shapes[uiShape.value]();

    window.onresize = resize;
    resize();
    faces = shapes.cube();
    draw();
</script>
</body>
</html>
